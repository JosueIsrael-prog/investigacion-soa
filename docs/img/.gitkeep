#  Bikestore Async â€” Proyecto Final

**Universidad de las AmÃ©ricas (UDLA)**
**Materia:** Arquitectura de Software
**Estudiante:** JosuÃ© Israel Cevallos Barbero
**Profesor:** Antonio Alejandro CaÃ±averal
**Fecha:** 5 de noviembre de 2025

---


#  Bikestore Async (Spring Boot + RabbitMQ)

Sistema asÃ­ncrono de pedidos y pagos con Spring Boot y RabbitMQ, utilizando colas, exchange tipo *topic*, DLQ y reintentos.

![Estructura del proyecto](docs/img/docsimgo1arbolproyecto.png)

---

## ï¸ TecnologÃ­as usadas

- **Java 17** â€” Lenguaje principal.
- **Spring Boot 3.5.7** â€” Framework backend.
- **Spring AMQP** â€” ComunicaciÃ³n con RabbitMQ.
- **RabbitMQ 3.13.x** â€” Broker de mensajerÃ­a.
- **Maven** â€” GestiÃ³n de dependencias.
- **IntelliJ IDEA** â€” Entorno de desarrollo.

---

##  Arquitectura general

La aplicaciÃ³n sigue un modelo **productorâ€“consumidor**:

1. **OrderProducer** â†’ envÃ­a mensajes al **Exchange** principal.
2. **RabbitMQ** los enruta hacia las **colas** configuradas (`orders.queue`, `email.queue`, etc.).
3. **OrderConsumer** y **EmailConsumer** reciben los mensajes.
4. Si ocurre un error (mensaje â€œfailâ€ o â€œdlqâ€), se redirige a la **cola DLQ** (`orders.dlq`).

---

![Configuracion de RabbitMQ](docs/img/02rabbitconfig.png)

---

##  ConfiguraciÃ³n de RabbitMQ y variables de la app

El archivo `application.yml` define la conexiÃ³n con RabbitMQ y los nombres de los exchanges, colas y routing keys usados en el proyecto.

- `spring.rabbitmq`: define el host, puerto y credenciales para conectarse al broker.
- `app.exchange`: nombre del exchange principal (`orders.exchange`).
- `app.queues`: define las colas (`orders.queue`, `email.queue`, `orders.dlq`).
- `app.rk`: routing keys usadas para enrutar mensajes (`order.created`, `email.send`, etc).

 **Captura:**
![ConfiguraciÃ³n del application.yml](docsimg03applicationyml.png)

---

## Productor (OrderProducer)

El **OrderProducer** expone un endpoint REST que permite enviar mensajes a RabbitMQ usando el mÃ©todo `convertAndSend()` del `RabbitTemplate`.

- Endpoint: **`GET /api/orders/send?msg=hola`**
- EnvÃ­a el mensaje al *exchange* principal (`orders.exchange`)
- Usa las *routing keys* configuradas en `application.yml`
- Los mensajes se enrutan a las colas correspondientes segÃºn el tipo.

 **Captura:**
![OrderProducer](docsimg04orderproducer.png)

---

##  Consumidores (OrderConsumer y EmailConsumer)

Los **consumidores** reciben los mensajes que se envÃ­an a las colas configuradas.
Cada uno estÃ¡ asociado a una cola distinta mediante la anotaciÃ³n `@RabbitListener`.

- **OrderConsumer:** procesa mensajes de la cola `orders.queue`.
  Si el mensaje contiene â€œfailâ€ o â€œdlqâ€, se **rechaza** y se redirige automÃ¡ticamente a la **DLQ (`orders.dlq`)**.
- **EmailConsumer:** procesa mensajes de la cola `email.queue`.
  Solo imprime el mensaje recibido en la consola.

 **Capturas:**

![OrderConsumer](docsimg05orderconsumer.png)
![EmailConsumer](docsimg06emailconsumer.png)

---

##  Resultados en RabbitMQ

Una vez iniciada la aplicaciÃ³n y enviados los mensajes desde el endpoint:

- Los mensajes vÃ¡lidos (`hola`, `ok`, etc.) llegan a la cola **`orders.queue`**.
- Los mensajes con error (`fail`, `dlq`, etc.) son redirigidos automÃ¡ticamente a la cola **DLQ (`orders.dlq`)**.

 **Capturas:**

![Cola orders.queue](docsimg07ordersqueue.png)
![Cola orders.dlq](docsimg08ordersdlq.png)


---

## ðŸ ConclusiÃ³n

Este proyecto demuestra el uso de **Spring Boot** y **RabbitMQ** para implementar un sistema de mensajerÃ­a **asÃ­ncrono y tolerante a fallos**.
Se logrÃ³ la conexiÃ³n entre productor y consumidores, el manejo de colas y el envÃ­o de mensajes hacia una **DLQ (Dead Letter Queue)** en caso de errores.
El sistema fue probado correctamente con resultados visibles en el panel de RabbitMQ.

---

>  *Desarrollado por JosuÃ© Cevallos â€” UDLA 2025*

